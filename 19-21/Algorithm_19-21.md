## Условия

Тип 19-21 - три задания на теорию игр.
Два игрока, Петя и Ваня, играют в игру и ходят поочерёдно.
ЗАПОМИНАЛКА: Петя = П = Первый, Ваня = В = Второй. Каждый ход играет сначала Петя, потом Ваня.

## Алгоритм

### Объявление функции

Эти задачи делятся на два типа: одна куча и две кучи. Наша программа может быть использована в обоих случаях.
Вначале мы объявляем функцию f(k1, k2, n) с аргументами: k1 - первая куча, k2 - вторая,
и n - количество оставшихся ходов.
Если куча одна, то пишем не три, а два аргумента: f(k, n). Про n мы поговорим позже.
На конце этой строки обязательно ставим двоеточие, а на следующей строке нажимаем Tab, как будто мы работаем с if.
_(Можно запомнить и так: если ставишь ":" => нужен tab на следующей строке)_

### Условие выигрыша

В условии задачи вам будет сказано, какое суммарное кол-во камней считается выигрышным.
Например, у нас две кучи. Победой считается ситуация, когда камней в обоих кучах, допустим, 40 и больше. Так и запишем:
```python
if k1 + k2 >= 40:
  return n % 2 == 0
```
Если мы убираем камни, а не добавляем, то вместо больше или равно пишем меньше или равно.

### Условие проигрыша (закончились ходы)

Теперь мы проверим, закончились ли ходы. Если да, то функция вернёт 0 и программа остановится:
```python
if n == 0:
  return 0
```

### Переносимся на ход вперед

После проверок отнимем от значения n единицу, тем самым мы сместимся на один ход вперёд,
т.е. перейдём к следующему игроку:
```python
n -= 1  # (Это то же самое, что и "n = n - 1")
```

### Получаем все варианты действий игрока (рекурсия)

Затем мы должны рассмотреть все возможные варианты действий игрока. Для этого создадим список,
в котором они и будут находиться в виде этой же функции, но только с изменёнными аргументами.
Например, мы можем добавить в любую кучу один камень или увеличить количество камней в одной куче в два раза.
Тогда функция с изменёнными аргументами будет выглядеть так:
Если добавляем в первую кучу один камень: f(k1 + 1, k2, n)
Если умножаем количество камней в первой куче в два раза: f(k1 * 2, k2, n)
Если добавляем во вторую кучу один камень: f(k1, k2 + 1, n)
Если умножаем количество камней во второй куче в два раза: f(k1, k2 * 2, n)

Теперь поместим все варианты в список v.
Не забываем соблюдать табуляцию (нажимать Tab, как здесь) и писать запятые после каждого варианта кроме последнего,
а также закрыть список квадратной скобкой в конце:
```python
v = [
  f(k1 + 1, k2, n),
  f(k1 * 2, k2, n),
  f(k1, k2 + 1, n),
  f(k1, k2 * 2, n),
]

# Можно и так, разницы, кроме читаемости, нет:
v = [f(k1 + 1, k2, n), f(k1 * 2, k2, n), f(k1, k2 + 1, n), f(k1, k2 * 2, n)]
```

Также мы можем совершать и другие действия:
Если убираем камни, то вместо плюса пишем минус.
Если уменьшаем количество камней в 2 раза, тут уже посложнее, ведь могут попасться нечётные числа,
а 1,5 камня быть не может.
В условии будет написано, сколько именно убирается камней в таком случае. Вот примеры:
Если количество камней в куче нечётно, остаётся на 1 камень МЕНЬШЕ, чем убирается.
Это можно записать так: (k1 + 1) // 2   ("//" - делить нацело, без остатка и округления)
Если количество камней в куче нечётно, остаётся на 1 камень БОЛЬШЕ, чем убирается. Это можно записать так: k1 // 2

### Обработка выигрышной стратегии: гарантированна и возможна

Мы знаем, что игроки ходят в таком порядке: 1 ход Пети, 1 ход Вани, 2 ход Пети, 2 ход Вани, ...
Каждое действие будем считать числом. Так, ходы будут обозначены следующим образом: 1, 2, 3, 4.
Т.е. 1 ход Пети = 1, 1 ход Вани = 2, и т.д. Это и есть значение n.
Теперь проверим, какой игрок играет. Если ход чётный, то играет Ваня, если нет - Петя.
Сначала давайте посмотрим, как выглядит вся конструкция.
```python
if n % 2 == 0:
  return any(v)
else:
  return any(v)
```

В шаблоне программы написано, что после return может стоять либо all, либо any.
Если игрок выигрывает при ЛЮБЫХ ходах, тогда пишем all. Если он может выиграть, но НЕ ПРИ ВСЕХ ХОДАХ, тогда пишем any.

_Также есть небольшой лайфхак. Практически всегда он работает, хотя я не знаю, как это объяснить.
Описанную выше конструкцию с if и else можно представить (__НО НИ В КОЕМ СЛУЧАЕ НЕ ОБЪЯСНИТЬ!!!__) таким образом:_
```python
if n % 2 == 0:
  return any(v)  # Это первый ход победившего игрока (Если Петя - то n = 1, а если Ваня, то n = 2)
else:
  return any(v)  # Это второй ход победившего игрока (Если Петя - то n = 3, а если Ваня, то n = 4)
```

В заданиях 20 и 21 побеждает один игрок за два хода. Либо Петя за свои первый и второй ходы,
либо Ваня за свои первый и второй ходы. Причём за второй ГАРАНТИРОВАННО (пишем all), а за первый - не факт (пишем any)
Значит, если, например, Петя ВОЗМОЖНО победит своим первым ходом и 100% победит вторым,
то сначала пишем any, а потом - all.
Это ТОЛЬКО ДЛЯ 20 и 21 заданий. В 19 задании везде должно быть any.

### Проверка всех возможных вариантов исходной ситуации игры

Здесь определение функции закончено, и на следующей строке мы убираем Tab, переходя в самое начало строки.

Далее нам нужно перебрать все возможные значения переменной k.
Если мы добавляем камни в кучи, то смотрим в условие. Там будет дан диапазон допустимых значений k.
Если убираем камни, то нам даётся только одно число - наименьшее. Чтобы наверняка решить задачу,
берём последнее число 10000.
Теперь запишем сам перебор через цикл for. Мы меняем кучу k2. Первая известна.
Не забывайте, что range не берёт последнее число, написанное в скобках!
То есть нужно написать число на 1 больше последнего числа, указанного в условии. Например:
_(range(1, 5) вернёт нам: 1, 2, 3, 4)_
```python
for k in range(1, 40):
```

Не забываем снова поставить Tab на следующей строке, ведь мы работаем с циклом.
Теперь запишем так называемую "ситуацию" в игре через if, то есть какой ход проиграл или выиграл.
Эта конструкция варьируется в зависимости от задания.
Это мы сделаем, вызвав функцию, которую ввели в самом начале, и найдя её значение при введённых нами аргументах.
Если кучи две, то вместо k1 пишем известное количество камней в одной из куч, k2 оставляем,
а вместо n пишем номер хода игрока, который мы описали ранее.
Если куча одна, то k оставляем, вместо n пишем номер хода.
Пусть, например, в первой куче было 3 камня.

__19 задание:__ Если Ваня выиграл после неудачного хода Пети, пишем так:
```python
if f(3, k2, 2) and not f(3, k2, 1):
  print(k2)
```
Перед этим два раза должны стоять any. Они там по умолчанию.
В основном просят одно число. Смотрим в вопрос задачи. На всякий случай проверяем первое и последнее числа,
если их несколько. Просчитываем ходы с ними и смотрим, подходят ли они. Выбираем правильный ответ.

__20 задание:__ Петя не может выиграть за один ход; Петя может выиграть своим вторым ходом независимо от того,
как будет ходить Ваня, значит пишем так:
```python
if f(3, k2, 3) and not f(3, k2, 1):
  print(k2)
```
Также меняем "нижний" any на all.
В основном просят два числа. Смотрим в вопрос задачи и записываем ответ БЕЗ ПРОБЕЛОВ, как одно большое число.

__21 задание:__ у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом, значит пишем так:
```python
if f(3, k2, 4) and not f(3, k2, 2):
  print(k2)
```
Перед этим мы поменяли один any на all. Оставляем, как есть.
В основном просят одно число. Смотрим в вопрос задачи и записываем ответ.
