# Тип 5 алгоритм:

[Задание =>](https://inf-ege.sdamgia.ru/problem?id=15791)

### Пишем программу для перебора исходных значений:

#### Справочные данные:

##### Типы данных:

В python каждая переменная имеет свой тип данных и свои свойства, их очень много, но вот минимально необходимые:
- int - integer - целочисленный (пример: x = 23)
- str - string - строковый (пример: x = 'hello world')

У каждого типа есть свои ограничения, например, сложить строку и число не получится, поэтому важно понимать,
какого типа конкретная переменная.

Это таблица с полезными функциями, преобразующими типы данных:

| функция |               пояснение               |
|:-------:|:-------------------------------------:|
|  str()  |   приводит к строковому типу данных   |
|  int()  | приводит к целочисленному типу данных |
|  bin()  |     создаёт двоичную запись числа     |

##### Срезы строк:
В python любую строку (str) можно срезать:
```python
x = 'hello world'

x = x[2:]
print(x)  # результат: "llo world"
```
Делается это посредством конструкции `[:]`, перед двоеточием можно поставить целое число и строка
срежется по нему, тоесть если мы сделаем срез по строке "hello" на два символа с начала `[2:]`, то получим "ello"

#### Разбор построчно:

Пишем основной цикл, в нём перебираем числа от 1 до 1000
(1000 можно поменять на другое число, просто именно 1000 
достаточно большое число для перебора и его просто написать (это не миллион)).
```python
for i in range(1, 1000):
```

Переводим наше число i в двоичную систему, после в строку и обрезаем два первых символа,
без этого строка выглядела бы так: "**0b**1001", таким образом мы избавляемся от "0b".
```python
i_bin_str = str(bin(i))[2:]
```

Далее в задании нам необходимо 2 раза сделать одно и тоже действие со строкой, поэтому мы
используем цикл, который запуститься 2 раза ("_" - сюда можно поставить любую переменную
(кроме i, её уже использовали ранее), но так как мы её использовать не будем, принято писать "_", это необязательно)
```python
for _ in range(2):
```

Далее в цикле определяем переменную, в которой будем хранить сумму строки (i_bin_str),
проходимся по ней в цикле (если написать `for j in i_bin_str`, то j будет присваиваться
по символу из i_bin_str, каждый цикл, когда символы в i_bin_str закончаться, цикл завершится),
прибавляем к summ j
(переведённую в целочисленный тип, так как строки как числа складываться не будут, а нам нужно именно это)
и прибавляем (уже как строковый тип) к i_bin_str остаток от деления summ на 2
(строки при сложении будут объединяться, "he" + "llo" = "hello").
```python
summ = 0

for j in i_bin_str:
    summ += int(j)

i_bin_str += str(summ % 2)
```

Далее переводим нашу двоичную запись в целое число (указываем 2 в качестве дополнительного аргумента функции
int(), чтобы перевести из двоичной системы в десятичную)
```python
result = int(i_bin_str, 2)
```

И, наконец, проверяем, подходит ли нам результат (должен быть больше 97), и если подходит, то
выводим его через print() и завершаем главный цикл с помощью break
(можно и без этого, но тогда вам выведется не одно число, а пара сотен и нужно будет взять первое из них для ответа)
```python
if result > 97:

    print(result)

    break
```

Итого ([файл](5_EZ.py)):
```python
for i in range(1, 1000):

    i_bin_str = str(bin(i))[2:]

    for _ in range(2):

        summ = 0

        for j in i_bin_str:
            summ += int(j)

        i_bin_str += str(summ % 2)

    result = int(i_bin_str, 2)

    if result > 97:

        print(result)

        break
```
